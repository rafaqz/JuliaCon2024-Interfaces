[
  {
    "objectID": "index.html#defining-interface-for-interfaces.jl",
    "href": "index.html#defining-interface-for-interfaces.jl",
    "title": "Interfaces.jl",
    "section": "Defining “interface” for Interfaces.jl",
    "text": "Defining “interface” for Interfaces.jl\n\nan interface is of a set of functions with documented contracts\nit may be tied to an abstract type, or not (think AbstractArray vs Tables.jl)\nbehaviour may be testable at compile-time or run-time\ninterfaces may have optional components\n\nFor AbstractArray, setindex! is not implemented for some StaticArrays.jl types"
  },
  {
    "objectID": "index.html#define-the-interface",
    "href": "index.html#define-the-interface",
    "title": "Interfaces.jl",
    "section": "Define the interface",
    "text": "Define the interface\n\n\nUsing the @interface macro:\n\nusing Interfaces\n \n@interface SetInterface AbstractSet components \"Defines AbstractSet behavior\"\n#          ^            ^           ^          ^\n#          name         supertype   tests      description\n\nMain.Notebook.SetInterface"
  },
  {
    "objectID": "index.html#define-mandatory-components",
    "href": "index.html#define-mandatory-components",
    "title": "Interfaces.jl",
    "section": "Define mandatory components:",
    "text": "Define mandatory components:\n\ncomponent = \"label\" =&gt; test_func\n\n\n\nmandatory = (;\n    isempty = \"defines `isempty` and testdata is not empty\" =&gt; !isempty,\n    eltype = \"elements eltype of set `s` are subtypes of `eltype(s)`\" =&gt; \n      s -&gt; typeof(first(iterate(s))) &lt;: eltype(s),\n    length = \"set defines length and test object has length larger than zero\" =&gt; \n      s -&gt; length(s) isa Int && length(s) &gt; 0,\n    in = \"`in` is true for all elements in the set\" =&gt; \n      s -&gt; all(x -&gt; x in s, s),\n);"
  },
  {
    "objectID": "index.html#define-optional-components",
    "href": "index.html#define-optional-components",
    "title": "Interfaces.jl",
    "section": "Define optional components:",
    "text": "Define optional components:\n\n\n\noptional = (;\n    copy = \"creates an identical object with the same values, that is not the same object\" =&gt; \n        s -&gt; (s1 = copy(s); s1 !== s && s1 isa typeof(s) && collect(s) == collect(s1)),\n    empty = (\n        \"returns an empty set able to hold elements of type U\" =&gt; \n            s -&gt; (s1 = Base.empty(s); isempty(s1) && eltype(s1) == eltype(s)),\n    ),\n    # Components can be a tuple of tests\n    intersect = (\n        \"`intersect` of set with itself is itself\" =&gt; s -&gt; intersect(s, s) == s,\n        \"`intersect` of set with an empty set is an empty set\" =&gt; s -&gt; intersect(s, empty(s)) == empty(s),\n    ),\n    # ...\n);\n\ncomponents = (; mandatory, optional);"
  },
  {
    "objectID": "index.html#declare-an-implementation",
    "href": "index.html#declare-an-implementation",
    "title": "Interfaces.jl",
    "section": "Declare an implementation",
    "text": "Declare an implementation\n\n\nUsing the @implements macro:\n\n@implements SetInterface{(:copy,:empty)} Set  [Set((1, 2)), Set((:a, :b))]\n#           ^                            ^    ^\n#           interface with options       type test data"
  },
  {
    "objectID": "index.html#test-the-implementation",
    "href": "index.html#test-the-implementation",
    "title": "Interfaces.jl",
    "section": "Test the implementation",
    "text": "Test the implementation\n\n\nInterfaces.test(SetInterface, Set)"
  },
  {
    "objectID": "index.html#test-all-the-implementations",
    "href": "index.html#test-all-the-implementations",
    "title": "Interfaces.jl",
    "section": "Test all the implementations",
    "text": "Test all the implementations\n\n\nInterfaces.test(SetInterface)"
  },
  {
    "objectID": "index.html#check-an-implementation-trait",
    "href": "index.html#check-an-implementation-trait",
    "title": "Interfaces.jl",
    "section": "Check an implementation trait",
    "text": "Check an implementation trait\nUsing the implements method:\n\nInterfaces.implements(SetInterface, Set)\n\ntrue\n\n\n\nInterfaces.implements(SetInterface{(:copy,:empty)}, Set)\n\ntrue\n\n\n\nInterfaces.implements(SetInterface{:intersect}, Set)\n\nfalse\n\n\nThis has no runtime cost:\n\n@btime Interfaces.implements(SetInterface{(:copy,:empty)}, Set)\n\n  1.552 ns (0 allocations: 0 bytes)\n\n\ntrue"
  },
  {
    "objectID": "index.html#check-help",
    "href": "index.html#check-help",
    "title": "Interfaces.jl",
    "section": "Check help",
    "text": "Check help\n\n\nhelp?&gt; SetInterface\nsearch: SetInterface\n\n      SetInterface\n\n  An Interfaces.jl Interface with mandatory components (:isempty, :eltype, :length, :in) and\n  optional components (:copy, :empty, :intersect).\n\n  Defines AbstractSet behavior\n\n  ──────────────────────────────────────────────────────────────────────────────────────────────────\n\nExtended help is available with `??`"
  },
  {
    "objectID": "index.html#check-extended-help",
    "href": "index.html#check-extended-help",
    "title": "Interfaces.jl",
    "section": "Check extended help",
    "text": "Check extended help\n\n\nhelp?&gt; ?SetInterface\nsearch: SetInterface\n\n      SetInterface\n\n  An Interfaces.jl Interface with mandatory components (:isempty, :eltype, :length, :in) and\n  optional components (:copy, :empty, :intersect).\n\n  Defines AbstractSet behavior\n\n  Extended help\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  Mandatory keys:\n  ===============\n\n    •  isempty: defines isempty and testdata is not empty\n\n    •  eltype: elements eltype of set s are subtypes of eltype(s)\n\n    •  length: set defines length and test object has length larger than zero\n\n    •  in: in is true for all elements in the set\n\n  Optional keys:\n  ==============\n\n    •  copy: creates an identical object with the same values, that is not the same object\n\n    •  empty:\n       • returns an empty set able to hold elements of type U\n\n    •  intersect:\n       • intersect of set with itself is itself\n       • intersect of set with an empty set is an empty set"
  },
  {
    "objectID": "index.html#the-abstractgraph-interface",
    "href": "index.html#the-abstractgraph-interface",
    "title": "Interfaces.jl",
    "section": "The AbstractGraph interface",
    "text": "The AbstractGraph interface\n\nA handful of methods to implement for AbstractGraph\nSome mandatory (vertices, edges), some optional (add_vertex!, add_edge!)\nFor a given graph, are these methods correct and coherent with one another?"
  },
  {
    "objectID": "index.html#an-automated-checker",
    "href": "index.html#an-automated-checker",
    "title": "Interfaces.jl",
    "section": "An automated checker",
    "text": "An automated checker\n\nGraphsInterfaceChecker.jl1 relies on Interfaces.jl to check graph implementations\nCompile-time check: nv(g) should be an integer\nRun-time check: nv(g) should be the length of vertices(g)\nLighter interpretation burden on the user\nMore reliable ecosystem\n\nwritten with Oleg Fafurin"
  }
]