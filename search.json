[
  {
    "objectID": "ideas.html",
    "href": "ideas.html",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "The state of automatic differentiation in Julia\nAutodiff in Julia from the user perspective\nA quick guide to autodiff in Julia\nA quick tour of AD in Julia\nNavigating the Julia AD ecosystem\nAD in Julia: A Beginner’s Guide to Backends and Beyond\nFrom Basics to Backends: A Complete Guide to Automatic Differentiation in Julia\n\n\n\n\n\nComplexity of the Julia ecosystem\n\nNumber of backends can be overwhelming / confusing (just open https://juliadiff.org/)\n\nDevs: Which backend do you use?\nUsers: Which function/method is differentiable with which backend?\n\nLots of folklore in Julia community\n\nA quick taxonomy of AD systems\n\nWe want gradients and more generally Jacobians\nAD systems only compute VJPs and JVPs\n\nFor function \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\)\n\n\\(n\\) JVPs to compute Jacobian\n\\(m\\) VJPs to compute Jacobian (\\(m=1\\) for e.g. neural networks with scalar loss)\n\nVJPs and JVPs compose really really well due to the chain rule\nwe are not actually allocating potential huge Jacobian matrices but working with functions\n\nfunctions computing JVPs: pushforwards\nfunctions computing VJPs: pullbacks\n\ngood way to broadly categorize AD systems\n\nthere are other exotic approaches\n\nStructure of Autodiff in Julia (compared to e.g. Python) “Julia Dreams Big”\n\nAmbitious goal: language-wide AD\n\nPackages use different AD “backends”\n\nPyTorch and JAX: sub-ecosystems\n\nAD “backends” have their own ecosystems\n\n\nReverse-mode’s “two language problem”\n\nDifferent ways to write Julia code (see “1.5 language problem”)\nIn autodiff it’s reversed (Zygote doesn’t support mutation)\n\nUsing Julia AD in 2024\n\nThere are three types of users:\n\npeople developing AD systems\npeople who want to make their functions differentiable\npeople who want to differentiate over a function\n\nAD developers\nMaking functions differentiable\n\nProbably want compatibility with as many backends as possible\nHow do you do this with ChainRules, Enzyme, ForwardDiff while being fast?\nIs it even possible to have code differentiable across all backends?\n\nDifferentiating over a function\n\nWhich backend is compatible with my problem?\nWhich backend is the fastest?\n\n\nThe solutions (?)\n\nReverse-diff over mutating code being solved by Enzyme\n\nWhy don’t we all just use Enzyme? Complicated interface\n\nAbstractDiff / Diff’Interface\n\nAbstract API allows quickly testing all backends and benchmarking them against each other\n\n\n\n\n\n\n\nhttps://adrianhill.de/julia-ml-course/L6_Automatic_Differentiation/\nhttps://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html"
  },
  {
    "objectID": "ideas.html#title",
    "href": "ideas.html#title",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "The state of automatic differentiation in Julia\nAutodiff in Julia from the user perspective\nA quick guide to autodiff in Julia\nA quick tour of AD in Julia\nNavigating the Julia AD ecosystem\nAD in Julia: A Beginner’s Guide to Backends and Beyond\nFrom Basics to Backends: A Complete Guide to Automatic Differentiation in Julia"
  },
  {
    "objectID": "ideas.html#draft-outline",
    "href": "ideas.html#draft-outline",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "Complexity of the Julia ecosystem\n\nNumber of backends can be overwhelming / confusing (just open https://juliadiff.org/)\n\nDevs: Which backend do you use?\nUsers: Which function/method is differentiable with which backend?\n\nLots of folklore in Julia community\n\nA quick taxonomy of AD systems\n\nWe want gradients and more generally Jacobians\nAD systems only compute VJPs and JVPs\n\nFor function \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\)\n\n\\(n\\) JVPs to compute Jacobian\n\\(m\\) VJPs to compute Jacobian (\\(m=1\\) for e.g. neural networks with scalar loss)\n\nVJPs and JVPs compose really really well due to the chain rule\nwe are not actually allocating potential huge Jacobian matrices but working with functions\n\nfunctions computing JVPs: pushforwards\nfunctions computing VJPs: pullbacks\n\ngood way to broadly categorize AD systems\n\nthere are other exotic approaches\n\nStructure of Autodiff in Julia (compared to e.g. Python) “Julia Dreams Big”\n\nAmbitious goal: language-wide AD\n\nPackages use different AD “backends”\n\nPyTorch and JAX: sub-ecosystems\n\nAD “backends” have their own ecosystems\n\n\nReverse-mode’s “two language problem”\n\nDifferent ways to write Julia code (see “1.5 language problem”)\nIn autodiff it’s reversed (Zygote doesn’t support mutation)\n\nUsing Julia AD in 2024\n\nThere are three types of users:\n\npeople developing AD systems\npeople who want to make their functions differentiable\npeople who want to differentiate over a function\n\nAD developers\nMaking functions differentiable\n\nProbably want compatibility with as many backends as possible\nHow do you do this with ChainRules, Enzyme, ForwardDiff while being fast?\nIs it even possible to have code differentiable across all backends?\n\nDifferentiating over a function\n\nWhich backend is compatible with my problem?\nWhich backend is the fastest?\n\n\nThe solutions (?)\n\nReverse-diff over mutating code being solved by Enzyme\n\nWhy don’t we all just use Enzyme? Complicated interface\n\nAbstractDiff / Diff’Interface\n\nAbstract API allows quickly testing all backends and benchmarking them against each other"
  },
  {
    "objectID": "ideas.html#sources",
    "href": "ideas.html#sources",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "https://adrianhill.de/julia-ml-course/L6_Automatic_Differentiation/\nhttps://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html"
  },
  {
    "objectID": "index.html#interfaces-have-compile-time-and-run-time-properties",
    "href": "index.html#interfaces-have-compile-time-and-run-time-properties",
    "title": "Interfaces in Julia",
    "section": "Interfaces have compile-time and run-time properties",
    "text": "Interfaces have compile-time and run-time properties\n\nCompile time:\n\nis a method defined at all?\nDoes it accept arguments of the allowed types?\n\nRun-time:\n\ndoes the method do what the interface states it does?\n\nExample:\n\nat compile-time check size returns a Tuple of Int\nat run-time check prod(size(x)) == length(x)"
  },
  {
    "objectID": "index.html#interfaces-have-optional-components",
    "href": "index.html#interfaces-have-optional-components",
    "title": "Interfaces in Julia",
    "section": "Interfaces have optional components",
    "text": "Interfaces have optional components\n\nMost reasonably complex interfaces in julia end up with optional components\nsetindex! is not implemented for some StaticaArrays.jl array types\noxinabox AbstractSet issue"
  },
  {
    "objectID": "index.html#define-mandatory-components",
    "href": "index.html#define-mandatory-components",
    "title": "Interfaces in Julia",
    "section": "Define mandatory components:",
    "text": "Define mandatory components:\n\n\n\nglobal mandatory = (;\n    isempty = \"defines `isempty` and testdata is not empty\" =&gt; !isempty,\n    eltype = \"elements eltype of set `s` are subtypes of `eltype(s)`\" =&gt; \n      s -&gt; typeof(first(iterate(s))) &lt;: eltype(s),\n    length = \"set defines length and test object has length larger than zero\" =&gt; \n      s -&gt; length(s) isa Int && length(s) &gt; 0,\n    # iteration = \"follows the IterationInterface\" =&gt; \n    #   s -&gt; Interfaces.test(IterationInterface, s; show=false),\n    in = \"`in` is true for elements in set\" =&gt; \n      s -&gt; all(x -&gt; in(x, s), s),\n);"
  },
  {
    "objectID": "index.html#and-optional-components",
    "href": "index.html#and-optional-components",
    "title": "Interfaces in Julia",
    "section": "And optional components:",
    "text": "And optional components:\n\n\n\nglobal optional = (;\n    copy = \"creates an identical object with the same values, that is not the same object\" =&gt; \n        s -&gt; (s1 = copy(s); s1 !== s && s1 isa typeof(s) && collect(s) == collect(s1)),\n    empty = (\n        \"returns an empty set able to hold elements of type U\" =&gt; \n            s -&gt; (s1 = Base.empty(s); isempty(s1) && eltype(s1) == eltype(s)),\n    ),\n    intersect = (\n        \"`intersect` of set with itself is itself\" =&gt; s -&gt; intersect(s, s) == s,\n        \"`intersect` of set with an empty set is an empty set\" =&gt; s -&gt; intersect(s, empty(s)) == empty(s),\n    ),\n    # ...\n);"
  },
  {
    "objectID": "index.html#define-the-interface",
    "href": "index.html#define-the-interface",
    "title": "Interfaces in Julia",
    "section": "Define the interface",
    "text": "Define the interface\n\n\nUsing the @interface macro:\n\nusing Interfaces\n@interface SetInterface AbstractSet (; mandatory, optional) \"The `AbstractSet` interface\"\n#          ^            ^           ^                       ^\n#          interface    supertype   test components         description\n\nMain.Notebook.SetInterface"
  },
  {
    "objectID": "index.html#declare-an-implementation",
    "href": "index.html#declare-an-implementation",
    "title": "Interfaces in Julia",
    "section": "Declare an implementation",
    "text": "Declare an implementation\n\n\nUsing the @implements macro:\n\n@implements SetInterface{(:copy,:empty)} Set  [Set((1, 2))]\n#           ^                                       ^    ^\n#           interface with options       type test data"
  },
  {
    "objectID": "index.html#check-the-implementation",
    "href": "index.html#check-the-implementation",
    "title": "Interfaces in Julia",
    "section": "Check the implementation",
    "text": "Check the implementation\n\n\nUsing the test method:\n\nInterfaces.test(SetInterface, Set)\n\n\nTesting SetInterface is implemented for Set\n\nMandatory components\nisempty: defines `isempty` and testdata is not empty [true]\neltype: elements eltype of set `s` are subtypes of `eltype(s)` [true]\nlength: set defines length and test object has length larger than zero [true]\nin: `in` is true for elements in set [true]\n\nOptional components\ncopy: creates an identical object with the same values, that is not the same object [true]\nempty: (returns an empty set able to hold elements of type U [true])\n\n\ntrue"
  },
  {
    "objectID": "index.html#check-all-the-implementations",
    "href": "index.html#check-all-the-implementations",
    "title": "Interfaces in Julia",
    "section": "Check all the implementations",
    "text": "Check all the implementations\n\n\n\n\nInterfaces.test(SetInterface)\n\n\nTesting SetInterface is implemented for Set\n\nMandatory components\nisempty: defines `isempty` and testdata is not empty [true]\neltype: elements eltype of set `s` are subtypes of `eltype(s)` [true]\nlength: set defines length and test object has length larger than zero [true]\nin: `in` is true for elements in set [true]\n\nOptional components\ncopy: creates an identical object with the same values, that is not the same object [true]\nempty: (returns an empty set able to hold elements of type U [true])\n\nImplementation summary:\n  Set correctly implements SetInterface: true\n\n\ntrue"
  },
  {
    "objectID": "index.html#check-an-implementation-trait",
    "href": "index.html#check-an-implementation-trait",
    "title": "Interfaces in Julia",
    "section": "Check an implementation trait",
    "text": "Check an implementation trait\n\n\nUsing the implements method:\n\n\nInterfaces.implements(SetInterface, Set)\n\ntrue\n\n\n\n\n\nInterfaces.implements(SetInterface{(:copy,:empty)}, Set)\n\ntrue\n\n\n\n\n\nInterfaces.implements(SetInterface{:intersect}, Set)\n\nfalse"
  },
  {
    "objectID": "index.html#case-study-graphs-ecosystem",
    "href": "index.html#case-study-graphs-ecosystem",
    "title": "Interfaces in Julia",
    "section": "Case study: Graphs ecosystem",
    "text": "Case study: Graphs ecosystem\n\nA handful of methods to implement AbstractGraph\nSome mandatory (vertices, edges), some optional (add_vertex!, add_edge!)\nMost properties of interest are not checkable at compile time: for a given graph, are accessors coherent with one another?\nDoes has_edge(g, u, v) return true on every element of edges(g)?\nPackage GraphsInterfaceChecker.jl to verify these properties for existing and new formats."
  }
]