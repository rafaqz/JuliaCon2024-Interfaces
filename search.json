[
  {
    "objectID": "ideas.html",
    "href": "ideas.html",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "The state of automatic differentiation in Julia\nAutodiff in Julia from the user perspective\nA quick guide to autodiff in Julia\nA quick tour of AD in Julia\nNavigating the Julia AD ecosystem\nAD in Julia: A Beginner’s Guide to Backends and Beyond\nFrom Basics to Backends: A Complete Guide to Automatic Differentiation in Julia\n\n\n\n\n\nComplexity of the Julia ecosystem\n\nNumber of backends can be overwhelming / confusing (just open https://juliadiff.org/)\n\nDevs: Which backend do you use?\nUsers: Which function/method is differentiable with which backend?\n\nLots of folklore in Julia community\n\nA quick taxonomy of AD systems\n\nWe want gradients and more generally Jacobians\nAD systems only compute VJPs and JVPs\n\nFor function \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\)\n\n\\(n\\) JVPs to compute Jacobian\n\\(m\\) VJPs to compute Jacobian (\\(m=1\\) for e.g. neural networks with scalar loss)\n\nVJPs and JVPs compose really really well due to the chain rule\nwe are not actually allocating potential huge Jacobian matrices but working with functions\n\nfunctions computing JVPs: pushforwards\nfunctions computing VJPs: pullbacks\n\ngood way to broadly categorize AD systems\n\nthere are other exotic approaches\n\nStructure of Autodiff in Julia (compared to e.g. Python) “Julia Dreams Big”\n\nAmbitious goal: language-wide AD\n\nPackages use different AD “backends”\n\nPyTorch and JAX: sub-ecosystems\n\nAD “backends” have their own ecosystems\n\n\nReverse-mode’s “two language problem”\n\nDifferent ways to write Julia code (see “1.5 language problem”)\nIn autodiff it’s reversed (Zygote doesn’t support mutation)\n\nUsing Julia AD in 2024\n\nThere are three types of users:\n\npeople developing AD systems\npeople who want to make their functions differentiable\npeople who want to differentiate over a function\n\nAD developers\nMaking functions differentiable\n\nProbably want compatibility with as many backends as possible\nHow do you do this with ChainRules, Enzyme, ForwardDiff while being fast?\nIs it even possible to have code differentiable across all backends?\n\nDifferentiating over a function\n\nWhich backend is compatible with my problem?\nWhich backend is the fastest?\n\n\nThe solutions (?)\n\nReverse-diff over mutating code being solved by Enzyme\n\nWhy don’t we all just use Enzyme? Complicated interface\n\nAbstractDiff / Diff’Interface\n\nAbstract API allows quickly testing all backends and benchmarking them against each other\n\n\n\n\n\n\n\nhttps://adrianhill.de/julia-ml-course/L6_Automatic_Differentiation/\nhttps://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html"
  },
  {
    "objectID": "ideas.html#title",
    "href": "ideas.html#title",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "The state of automatic differentiation in Julia\nAutodiff in Julia from the user perspective\nA quick guide to autodiff in Julia\nA quick tour of AD in Julia\nNavigating the Julia AD ecosystem\nAD in Julia: A Beginner’s Guide to Backends and Beyond\nFrom Basics to Backends: A Complete Guide to Automatic Differentiation in Julia"
  },
  {
    "objectID": "ideas.html#draft-outline",
    "href": "ideas.html#draft-outline",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "Complexity of the Julia ecosystem\n\nNumber of backends can be overwhelming / confusing (just open https://juliadiff.org/)\n\nDevs: Which backend do you use?\nUsers: Which function/method is differentiable with which backend?\n\nLots of folklore in Julia community\n\nA quick taxonomy of AD systems\n\nWe want gradients and more generally Jacobians\nAD systems only compute VJPs and JVPs\n\nFor function \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\)\n\n\\(n\\) JVPs to compute Jacobian\n\\(m\\) VJPs to compute Jacobian (\\(m=1\\) for e.g. neural networks with scalar loss)\n\nVJPs and JVPs compose really really well due to the chain rule\nwe are not actually allocating potential huge Jacobian matrices but working with functions\n\nfunctions computing JVPs: pushforwards\nfunctions computing VJPs: pullbacks\n\ngood way to broadly categorize AD systems\n\nthere are other exotic approaches\n\nStructure of Autodiff in Julia (compared to e.g. Python) “Julia Dreams Big”\n\nAmbitious goal: language-wide AD\n\nPackages use different AD “backends”\n\nPyTorch and JAX: sub-ecosystems\n\nAD “backends” have their own ecosystems\n\n\nReverse-mode’s “two language problem”\n\nDifferent ways to write Julia code (see “1.5 language problem”)\nIn autodiff it’s reversed (Zygote doesn’t support mutation)\n\nUsing Julia AD in 2024\n\nThere are three types of users:\n\npeople developing AD systems\npeople who want to make their functions differentiable\npeople who want to differentiate over a function\n\nAD developers\nMaking functions differentiable\n\nProbably want compatibility with as many backends as possible\nHow do you do this with ChainRules, Enzyme, ForwardDiff while being fast?\nIs it even possible to have code differentiable across all backends?\n\nDifferentiating over a function\n\nWhich backend is compatible with my problem?\nWhich backend is the fastest?\n\n\nThe solutions (?)\n\nReverse-diff over mutating code being solved by Enzyme\n\nWhy don’t we all just use Enzyme? Complicated interface\n\nAbstractDiff / Diff’Interface\n\nAbstract API allows quickly testing all backends and benchmarking them against each other"
  },
  {
    "objectID": "ideas.html#sources",
    "href": "ideas.html#sources",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "https://adrianhill.de/julia-ml-course/L6_Automatic_Differentiation/\nhttps://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html"
  },
  {
    "objectID": "index.html#interfaces-have-compile-time-and-run-time-properties",
    "href": "index.html#interfaces-have-compile-time-and-run-time-properties",
    "title": "Interfaces.jl",
    "section": "Interfaces have compile-time and run-time properties",
    "text": "Interfaces have compile-time and run-time properties\n\nCompile time:\n\nis a method defined at all?\nDoes it accept arguments of the allowed types?\n\nRun-time:\n\ndoes the method do what the interface states it does?\n\nExample:\n\nat compile-time check size returns a Tuple of Int\nat run-time check prod(size(x)) == length(x)"
  },
  {
    "objectID": "index.html#interfaces-have-optional-components",
    "href": "index.html#interfaces-have-optional-components",
    "title": "Interfaces.jl",
    "section": "Interfaces have optional components",
    "text": "Interfaces have optional components\n\nsetindex! is not implemented for some StaticArrays.jl array types\noxinabox AbstractSet issue"
  },
  {
    "objectID": "index.html#define-mandatory-components",
    "href": "index.html#define-mandatory-components",
    "title": "Interfaces.jl",
    "section": "Define mandatory components:",
    "text": "Define mandatory components:\n\nFormat: component = \"label\" =&gt; test_func\n\n\n\nmandatory = (;\n    isempty = \"defines `isempty` and testdata is not empty\" =&gt; !isempty,\n    eltype = \"elements eltype of set `s` are subtypes of `eltype(s)`\" =&gt; \n      s -&gt; typeof(first(iterate(s))) &lt;: eltype(s),\n    length = \"set defines length and test object has length larger than zero\" =&gt; \n      s -&gt; length(s) isa Int && length(s) &gt; 0,\n    in = \"`in` is true for elements in set\" =&gt; \n      s -&gt; all(x -&gt; in(x, s), s),\n);"
  },
  {
    "objectID": "index.html#define-optional-components",
    "href": "index.html#define-optional-components",
    "title": "Interfaces.jl",
    "section": "Define optional components:",
    "text": "Define optional components:\n\n\n\noptional = (;\n    copy = \"creates an identical object with the same values, that is not the same object\" =&gt; \n        s -&gt; (s1 = copy(s); s1 !== s && s1 isa typeof(s) && collect(s) == collect(s1)),\n    empty = (\n        \"returns an empty set able to hold elements of type U\" =&gt; \n            s -&gt; (s1 = Base.empty(s); isempty(s1) && eltype(s1) == eltype(s)),\n    ),\n    # Components can be a tuple of tests\n    intersect = (\n        \"`intersect` of set with itself is itself\" =&gt; s -&gt; intersect(s, s) == s,\n        \"`intersect` of set with an empty set is an empty set\" =&gt; s -&gt; intersect(s, empty(s)) == empty(s),\n    ),\n    # ...\n);"
  },
  {
    "objectID": "index.html#define-the-interface",
    "href": "index.html#define-the-interface",
    "title": "Interfaces.jl",
    "section": "Define the interface",
    "text": "Define the interface\n\n\nUsing the @interface macro:\n\nusing Interfaces\n@interface SetInterface AbstractSet (; mandatory, optional) \"Defines AbstractSet behavior\"\n#          ^            ^           ^                       ^\n#          interface    supertype   test components         description\n\nMain.Notebook.SetInterface"
  },
  {
    "objectID": "index.html#declare-an-implementation",
    "href": "index.html#declare-an-implementation",
    "title": "Interfaces.jl",
    "section": "Declare an implementation",
    "text": "Declare an implementation\n\n\nUsing the @implements macro:\n\n@implements SetInterface{(:copy,:empty)} Set  [Set((1, 2)), Set((:a, :b))]\n#           ^                            ^    ^\n#           interface with options       type test data"
  },
  {
    "objectID": "index.html#test-the-implementation",
    "href": "index.html#test-the-implementation",
    "title": "Interfaces.jl",
    "section": "Test the implementation",
    "text": "Test the implementation\nUsing the test method:\n\nInterfaces.test(SetInterface, Set)\n\n\nTesting SetInterface is implemented for Set\n\nMandatory components\nisempty: defines `isempty` and testdata is not empty [true, true]\neltype: elements eltype of set `s` are subtypes of `eltype(s)` [true, true]\nlength: set defines length and test object has length larger than zero [true, true]\nin: `in` is true for elements in set [true, true]\n\nOptional components\ncopy: creates an identical object with the same values, that is not the same object [true, true]\nempty: (returns an empty set able to hold elements of type U [true, true])\n\n\ntrue"
  },
  {
    "objectID": "index.html#test-all-the-implementations",
    "href": "index.html#test-all-the-implementations",
    "title": "Interfaces.jl",
    "section": "Test all the implementations",
    "text": "Test all the implementations\n\nInterfaces.test(SetInterface)\n\n\nTesting SetInterface is implemented for Set\n\nMandatory components\nisempty: defines `isempty` and testdata is not empty [true, true]\neltype: elements eltype of set `s` are subtypes of `eltype(s)` [true, true]\nlength: set defines length and test object has length larger than zero [true, true]\nin: `in` is true for elements in set [true, true]\n\nOptional components\ncopy: creates an identical object with the same values, that is not the same object [true, true]\nempty: (returns an empty set able to hold elements of type U [true, true])\n\nImplementation summary:\n  Set correctly implements SetInterface: true\n\n\ntrue"
  },
  {
    "objectID": "index.html#check-an-implementation-trait",
    "href": "index.html#check-an-implementation-trait",
    "title": "Interfaces.jl",
    "section": "Check an implementation trait",
    "text": "Check an implementation trait\n\nUsing the implements method:\n\n\nInterfaces.implements(SetInterface, Set)\n\ntrue\n\n\n\n\n\nInterfaces.implements(SetInterface{(:copy,:empty)}, Set)\n\ntrue\n\n\n\n\n\nInterfaces.implements(SetInterface{:intersect}, Set)\n\nfalse"
  },
  {
    "objectID": "index.html#check-help",
    "href": "index.html#check-help",
    "title": "Interfaces.jl",
    "section": "Check help",
    "text": "Check help\n\n\nhelp?&gt; SetInterface\nsearch: SetInterface\n\n      SetInterface\n\n  An Interfaces.jl Interface with mandatory components (:isempty, :eltype, :length, :in) and\n  optional components (:copy, :empty, :intersect).\n\n  Defines AbstractSet behavior\n\n  ──────────────────────────────────────────────────────────────────────────────────────────────────\n\nExtended help is available with `??`"
  },
  {
    "objectID": "index.html#check-extended-help",
    "href": "index.html#check-extended-help",
    "title": "Interfaces.jl",
    "section": "Check extended help",
    "text": "Check extended help\n\n\nhelp?&gt; ?SetInterface\nsearch: SetInterface\n\n      SetInterface\n\n  An Interfaces.jl Interface with mandatory components (:isempty, :eltype, :length, :in) and\n  optional components (:copy, :empty, :intersect).\n\n  Defines AbstractSet behavior\n\n  Extended help\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  Mandatory keys:\n  ===============\n\n    •  isempty: defines isempty and testdata is not empty\n\n    •  eltype: elements eltype of set s are subtypes of eltype(s)\n\n    •  length: set defines length and test object has length larger than zero\n\n    •  in: in is true for elements in set\n\n  Optional keys:\n  ==============\n\n    •  copy: creates an identical object with the same values, that is not the same object\n\n    •  empty:\n       • returns an empty set able to hold elements of type U\n\n    •  intersect:\n       • intersect of set with itself is itself\n       • intersect of set with an empty set is an empty set"
  }
]