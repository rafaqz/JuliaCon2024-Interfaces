---
title: "Interfaces.jl"
subtitle: "interface tests for your objects"
author:
  - name: Rafael Schouten
    orcid: 
    email: rafaelschouten@gmail.com
    affiliation: 
      - name: Globe Intstitute, Copenhagen University
      - department: Section for Biodiversity
  - name: Guillaume Dalle
    orcid: 0000-0003-4866-1687
    email: guillaume.dalle@epfl.ch
    affiliation: 
      - name: EPFL
      - department: IdePHICS, INDY & SPOC laboratories
date: "2024-07-11"
# bibliography: AutoDiff.bib
engine: julia
format:
  revealjs:
    incremental: true
    toc: false
    toc-depth: 1
    slide-number: true
    overview: true
    code-line-numbers: false
    theme: [night] # beige blood dark default league moon night serif simple sky solarized
execute:
    echo: true
---

# Motivation

- Julia has no formal interfaces
- People have complained about this

---

<iframe src="https://yuri.is/not-julia/" style="background-color: white; width: 100%; aspect-ratio: 1.2;"></iframe>
--- 

# What is an “interface”

- objects must accepted in a specific set of methods 
- methods should behave as the function documentation specifies

## Interfaces have *compile-time* and *run-time* properties

- Compile time: 
  - is a method defined at all?
  - Does it accept arguments of the allowed types?
- Run-time: 
  - does the method do what the interface states it does?
- Example: 
  - at compile-time check `size` returns a Tuple of `Int`
  - at run-time check `prod(size(x)) == length(x)`

## Interfaces have optional components 

- `setindex!` is not implemented for some StaticArrays.jl array types
- [oxinabox AbstractSet issue]('https://github.com/JuliaLang/julia/issues/34677')

# Interfaces.jl approach

## Define mandatory components:

```{julia}
#| echo: false
# Not sure why we need this
global mandatory
global optional
using BenchmarkTools
```
\
Format: `component = "label" => test_func`
\
\
```{julia}
mandatory = (;
    isempty = "defines `isempty` and testdata is not empty" => !isempty,
    eltype = "elements eltype of set `s` are subtypes of `eltype(s)`" => 
      s -> typeof(first(iterate(s))) <: eltype(s),
    length = "set defines length and test object has length larger than zero" => 
      s -> length(s) isa Int && length(s) > 0,
    in = "`in` is true for elements in set" => 
      s -> all(x -> in(x, s), s),
);
```

---

## Define optional components:
\
```{julia}
optional = (;
    copy = "creates an identical object with the same values, that is not the same object" => 
        s -> (s1 = copy(s); s1 !== s && s1 isa typeof(s) && collect(s) == collect(s1)),
    empty = (
        "returns an empty set able to hold elements of type U" => 
            s -> (s1 = Base.empty(s); isempty(s1) && eltype(s1) == eltype(s)),
    ),
    # Components can be a tuple of tests
    intersect = (
        "`intersect` of set with itself is itself" => s -> intersect(s, s) == s,
        "`intersect` of set with an empty set is an empty set" => s -> intersect(s, empty(s)) == empty(s),
    ),
    # ...
);
```

## Define the interface 
\
\
Using the `@interface` macro:

```{julia}
using Interfaces
@interface SetInterface AbstractSet (; mandatory, optional) "Defines AbstractSet behavior"
#          ^            ^           ^                       ^
#          interface    supertype   test components         description
```

## Declare an implementation
\
\
Using the `@implements` macro:

```{julia}
@implements SetInterface{(:copy,:empty)} Set  [Set((1, 2)), Set((:a, :b))]
#           ^                            ^    ^
#           interface with options       type test data
```

## Test the implementation
Using the `test` method:
```{julia}
Interfaces.test(SetInterface, Set)
```

## Test all the implementations
```{julia}
Interfaces.test(SetInterface)
```

## Check an implementation trait 
\
Using the `implements` method:
\
```{julia}
Interfaces.implements(SetInterface, Set)
```
\
```{julia}
Interfaces.implements(SetInterface{(:copy,:empty)}, Set)
```
\
```{julia}
Interfaces.implements(SetInterface{:intersect}, Set)
```
---

This has no runtime cost:
\
```{julia}
@btime Interfaces.implements(SetInterface{(:copy,:empty)}, Set)
```

## Check help
\
```julia
help?> SetInterface
search: SetInterface

      SetInterface

  An Interfaces.jl Interface with mandatory components (:isempty, :eltype, :length, :in) and
  optional components (:copy, :empty, :intersect).

  Defines AbstractSet behavior

  ──────────────────────────────────────────────────────────────────────────────────────────────────

Extended help is available with `??`
```

## Check extended help
\
```julia
help?> ?SetInterface
search: SetInterface

      SetInterface

  An Interfaces.jl Interface with mandatory components (:isempty, :eltype, :length, :in) and
  optional components (:copy, :empty, :intersect).

  Defines AbstractSet behavior

  Extended help
  ≡≡≡≡≡≡≡≡≡≡≡≡≡

  Mandatory keys:
  ===============

    •  isempty: defines isempty and testdata is not empty

    •  eltype: elements eltype of set s are subtypes of eltype(s)

    •  length: set defines length and test object has length larger than zero

    •  in: in is true for elements in set

  Optional keys:
  ==============

    •  copy: creates an identical object with the same values, that is not the same object

    •  empty:
       • returns an empty set able to hold elements of type U

    •  intersect:
       • intersect of set with itself is itself
       • intersect of set with an empty set is an empty set
```

# Case study: Graphs ecosystem

- A handful of methods to implement `AbstractGraph`
- Some mandatory (`vertices`, `edges`), some optional (`add_vertex!`, `add_edge!`)
- Most properties of interest are not checkable at compile time: for a given graph, are accessors coherent with one another?
- Does `has_edge(g, u, v)` return true on every element of `edges(g)`?
- Package GraphsInterfaceChecker.jl to verify these properties for existing and new formats.
