---
title: "Interfaces in Julia"
subtitle: ""
author:
  - name: Rafael Schouten
    orcid: 
    email: rafaelschouten@gmail.com
    affiliation: 
      - name: Globe Intstitute, Copenhagen University
      - department: Section for Biodiversity
  - name: Guillaume Dalle
    orcid: 0000-0003-4866-1687
    email: guillaume.dalle@epfl.ch
    affiliation: 
      - name: EPFL
      - department: IdePHICS, INDY & SPOC laboratories
date: "2024-07-11"
# bibliography: AutoDiff.bib
engine: julia
format:
  revealjs:
    incremental: true
    toc: true
    toc-depth: 1
    slide-number: true
    overview: true
    code-line-numbers: false
    theme: [serif] # beige blood dark default league moon night serif simple sky solarized
execute:
    echo: true
---

# Motivation

- Julia has no formal interfaces
- People have complained about this

---

<iframe src="https://yuri.is/not-julia/" style="width: 100%; aspect-ratio: 1.2;"></iframe>

--- 

# What we mean by an “interface”

- objects must define a specific set of methods 
- methods should behave as specified by their function documentation

## Interfaces have *compile-time* and *run-time* properties

- Compile time: 
  - is a method defined at all?
  - Does it accept arguments of the allowed types?
- Run-time: 
  - does the method do what the interface states it does?
- Example: 
  - at compile-time check `size` returns a Tuple of `Int`
  - at run-time check `prod(size(x)) == length(x)`

## Interfaces have optional components 

- Most reasonably complex interfaces in julia end up with optional components
- `setindex!` is not implemented for some StaticaArrays.jl array types
- [oxinabox AbstractSet issue]('https://github.com/JuliaLang/julia/issues/34677')

# Interfaces.jl approach

## Define mandatory components:

\
```{julia}
global mandatory = (;
    isempty = "defines `isempty` and testdata is not empty" => !isempty,
    eltype = "elements eltype of set `s` are subtypes of `eltype(s)`" => 
      s -> typeof(first(iterate(s))) <: eltype(s),
    length = "set defines length and test object has length larger than zero" => 
      s -> length(s) isa Int && length(s) > 0,
    # iteration = "follows the IterationInterface" => 
    #   s -> Interfaces.test(IterationInterface, s; show=false),
    in = "`in` is true for elements in set" => 
      s -> all(x -> in(x, s), s),
);
```

---

## And optional components:
\
```{julia}
global optional = (;
    copy = "creates an identical object with the same values, that is not the same object" => 
        s -> (s1 = copy(s); s1 !== s && s1 isa typeof(s) && collect(s) == collect(s1)),
    empty = (
        "returns an empty set able to hold elements of type U" => 
            s -> (s1 = Base.empty(s); isempty(s1) && eltype(s1) == eltype(s)),
    ),
    intersect = (
        "`intersect` of set with itself is itself" => s -> intersect(s, s) == s,
        "`intersect` of set with an empty set is an empty set" => s -> intersect(s, empty(s)) == empty(s),
    ),
    # ...
);
```

## Define the interface 
\
\
Using the `@interface` macro:

```{julia}
using Interfaces
@interface SetInterface AbstractSet (; mandatory, optional) "The `AbstractSet` interface"
#          ^            ^           ^                       ^
#          interface    supertype   test components         description
```

## Declare an implementation
\
\
Using the `@implements` macro:

```{julia}
@implements SetInterface{(:copy,:empty)} Set  [Set((1, 2))]
#           ^                                       ^    ^
#           interface with options       type test data
```

## Check the implementation
\
\
Using the `test` method:
```{julia}
Interfaces.test(SetInterface, Set)
```

## Check all the implementations
\
\
```{julia}
Interfaces.test(SetInterface)
```

## Check an implementation trait 
\
\
Using the `implements` method:
\
```{julia}
Interfaces.implements(SetInterface, Set)
```
\
```{julia}
Interfaces.implements(SetInterface{(:copy,:empty)}, Set)
```
\
```{julia}
Interfaces.implements(SetInterface{:intersect}, Set)
```
---

This has no runtime cost:

```{julia}
using BenchmarkTools
@btime Interfaces.implements(SetInterface{(:copy,:empty)}, Set)
```

## Case study: Graphs ecosystem

- A handful of methods to implement `AbstractGraph`
- Some mandatory (`vertices`, `edges`), some optional (`add_vertex!`, `add_edge!`)
- Most properties of interest are not checkable at compile time: for a given graph, are accessors coherent with one another?
- Does `has_edge(g, u, v)` return true on every element of `edges(g)`?
- Package GraphsInterfaceChecker.jl to verify these properties for existing and new formats.
